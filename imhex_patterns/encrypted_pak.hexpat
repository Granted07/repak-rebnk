#include <std/string.pat>
#include <std/math.pat>
#include <std/file.pat>
fn get_version_size(){
    return 221;
};
struct Footer{
    u128 encryption_uuid;
    bool is_encrypted;
    u32 magic;
    u32 version;
    u64 index_offset;
    u64 index_size;
    u8 hash[20];
    bool frozen;
    char string[sizeof($) - $];
};

u64 start = sizeof($) - get_version_size();



Footer footer @start;

// INDEX AND FOOTER ARE ENCRYPTED, CREATE DIFFERENT SECTIONS AND LOAD UNENCRYPTED DUMPS FROM REPAK
u8 index[footer.index_size] @ footer.index_offset;
std::mem::Section encrypted_idx = std::mem::create_section("Encrypted index");
std::mem::copy_value_to_section(index,encrypted_idx,0x0);
// export the index from section and run the script now


// RUN THIS ON DECRYPTED INDEX GENERATED BY PYTHON SCRIPT
std::file::Handle decrypted_file = std::file::open("C:\\Users\\natimerry\\RustroverProjects\\repak-rivals\\imhex_patterns\\decrypted_index.bin",1);
u32 decrypted_idx_size = std::file::size(decrypted_file);
std::mem::Section decrypted_idx = std::mem::create_section("Decrypted index");
std::mem::copy_value_to_section(std::file::read(decrypted_file,decrypted_idx_size),decrypted_idx,0x0);

struct DecryptedIndex{
    s32 len;
    char buf[len];
    
    u64 path_hash_seed;
    u32 record_count;
    u32 hash_path_index;
    

    u64 phi_offset;
    u64 phi_size;
    u8 _phi_hash[20];
    
    
    u32 has_fdi;
    u64 fdi_offset;
    u64 full_directory_index_size;
    u8 fdi_hash[20];
        
    u32 encoded_entry_size;
};

DecryptedIndex dx @ 0x00 in decrypted_idx;



u8 path_hash_index_buf[dx.phi_size] @ dx.phi_offset [[color("d06c3b")]];
u8 fdi_buf[dx.full_directory_index_size] @ dx.fdi_offset [[color("e744c9")]];

u8 magic[start - $] @ $ [[color("FF0000")]];