#include <std/string.pat>
#include <std/math.pat>
#include <std/file.pat>

fn get_version_size(){
    return 221;
};


struct Footer{
    u128 encryption_uuid;
    bool is_encrypted;
    u32 magic;
    u32 version;
    u64 index_offset;
    u64 index_size;
    u8 hash[20];
    bool frozen;
    char string[sizeof($) - $];
};

u64 start = sizeof($) - get_version_size();

u8 magic[35] @ start - 35;

Footer footer @start;


// INDEX AND FOOTER ARE ENCRYPTED, CREATE DIFFERENT SECTIONS AND LOAD UNENCRYPTED DUMPS FROM REPAK
u8 index[footer.index_size] @ footer.index_offset;

std::mem::Section encrypted_idx = std::mem::create_section("Encrypted index");


std::mem::copy_value_to_section(index,encrypted_idx,0x0);
// export the index from section and run the script now


// RUN THIS ON DECRYPTED INDEX GENERATED BY PYTHON SCRIPT
std::file::Handle decrypted_file = std::file::open("C:\\Users\\natimerry\\RustroverProjects\\repak-rivals\\imhex_patterns\\decrypted_index.bin",1);

u32 decrypted_idx_size = std::file::size(decrypted_file);

std::mem::Section decrypted_idx = std::mem::create_section("Decrypted index");


std::mem::copy_value_to_section(std::file::read(decrypted_file,decrypted_idx_size),decrypted_idx,0x0);

struct DecryptedIndex{
    s32 len;
    char buf[len];
    u64 path_hash_seed;
    u32 _path_hash_index;
    u64 path_hash_index_offset;
    u64 path_hash_index_size;
    u8 _path_hash_index_hash[20];

    u32 has_fdi;
    u64 fdi_offset;
    u64 full_directory_index_size;
    u8 fdi_hash[20];

    u32 encoded_entry_size;
    u8 data[encoded_entry_size];
};

DecryptedIndex dx @ 0x00 in decrypted_idx;
if (dx.len < 0){
    dx.len = - dx.len;
};
